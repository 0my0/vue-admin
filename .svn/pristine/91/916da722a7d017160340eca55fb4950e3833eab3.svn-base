{"remainingRequest":"E:\\vueProject\\admin\\vue-element-admin\\node_modules\\thread-loader\\dist\\cjs.js!E:\\vueProject\\admin\\vue-element-admin\\node_modules\\babel-loader\\lib\\index.js!E:\\vueProject\\admin\\vue-element-admin\\src\\store\\modules\\permission.js","dependencies":[{"path":"E:\\vueProject\\admin\\vue-element-admin\\src\\store\\modules\\permission.js","mtime":1573795430703},{"path":"E:\\vueProject\\admin\\vue-element-admin\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\vueProject\\admin\\vue-element-admin\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\vueProject\\admin\\vue-element-admin\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport _objectSpread from \"E:\\\\vueProject\\\\admin\\\\vue-element-admin\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/objectSpread2\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/web.dom.iterable\";\nimport { asyncRoutes, constantRoutes } from '@/router';\n/**\n * Use meta.role to determine if the current user has permission\n * @param roles\n * @param route\n */\n\nfunction hasPermission(roles, route) {\n  // console.log(roles)\n  roles.forEach(function (res) {// console.log(res)\n  });\n\n  if (route.meta && route.meta.permission_name) {\n    // console.log(roles.some(role => {route.meta.permission_name.includes(role)}))\n    return roles.some(function (role) {\n      var roleArr = role.split(\"/\"); // console.log(route.meta.permission_name , roleArr[roleArr.length-1] , route.meta.permission_name.includes(roleArr[roleArr.length-1]))\n\n      return route.meta.permission_name.includes(roleArr[roleArr.length - 1]);\n    });\n  } else {\n    return false;\n  }\n}\n/**\n * Filter asynchronous routing tables by recursion\n * @param routes asyncRoutes\n * @param roles\n */\n\n\nfunction filterAsyncRoutes(routes, roles) {\n  var res = [];\n  routes.forEach(function (route) {\n    var tmp = _objectSpread({}, route);\n\n    if (hasPermission(roles, tmp)) {\n      // 是否存在子节点，存在子节点说明当前节点为展开栏，并非页面\n      if (tmp.children) {\n        tmp.children = filterAsyncRoutes(tmp.children, roles); // forCheck() 方法递归判断该节点下是否存在页面，不存在则隐藏\n        // true：不存在，false：存在\n\n        tmp.hidden = forCheck(tmp.children);\n      }\n\n      res.push(tmp);\n    }\n  });\n  return res;\n} //\n\n\nfunction forCheck(routes) {\n  // 设置默认为隐藏\n  var isHidden = true; // 判断是否存页面，不存在说明该节点下不存在页面\n\n  if (routes.length > 0) {\n    // 循环子目录，如果子目录中不存在需要权限页面\n    // 说明子页面全是展开栏，隐藏\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = routes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var route = _step.value;\n\n        // 存在 permission 说明为页面，不存在说明为展开栏，将子页面列表继续递归\n        if (route.meta && route.meta.permission_name) {\n          isHidden = false;\n          return;\n        } else {\n          isHidden = forCheck(route.children);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return isHidden;\n} // const permission = {\n//   state: {\n//     routers: constantRoutes,\n//     addRouters: []\n//   },\n//   mutations : {\n//     SET_ROUTES: (state, routes) => {\n//       state.addRoutes = routes\n//       state.routes = constantRoutes.concat(routes)\n//     }\n//   },\n//   actions : {\n//     generateRoutes({ commit }, roles) {\n//       return new Promise(resolve => {\n//         const { roles } = data\n//         let accessedRoutes\n//         if (roles.includes('system')) {\n//           accessedRoutes = asyncRoutes || []\n//         } else {\n//           accessedRoutes = filterAsyncRoutes(asyncRoutes  , roles)\n//         }\n//         commit('SET_ROUTES', accessedRoutes)\n//         resolve(accessedRoutes)\n//       })\n//     }\n//   }\n// }\n\n\nvar state = {\n  routes: constantRoutes,\n  addRoutes: []\n};\nvar mutations = {\n  SET_ROUTES: function SET_ROUTES(state, routes) {\n    state.addRoutes = routes;\n    state.routes = constantRoutes.concat(routes);\n  }\n};\nvar actions = {\n  generateRoutes: function generateRoutes(_ref, priv) {\n    var commit = _ref.commit;\n    return new Promise(function (resolve) {\n      var accessedRoutes;\n\n      if (priv.length === 0) {\n        accessedRoutes = asyncRoutes || [];\n      } else {\n        accessedRoutes = filterAsyncRoutes(asyncRoutes, priv);\n      }\n\n      commit('SET_ROUTES', accessedRoutes);\n      resolve(accessedRoutes);\n    });\n  }\n};\nexport default {\n  namespaced: true,\n  state: state,\n  mutations: mutations,\n  actions: actions\n};",null]}